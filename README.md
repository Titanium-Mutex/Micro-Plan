# Micro-Plan
## 由来

マイクロプランは、1978年のbit誌(共立出版）のマイクロコンピュータ用プログラム増刊号に、「マイクロプランのプロセッサ」として、戸村哲氏が公表された小さな言語であり、増刊号には、その文法、コンパイラ、ローダ、インタプリタ、コンパイラ初期化用のID表が掲載された。ソースコードは、マイクロプランで記述され、約400行、11kBのサイズであった。これを実際にコンパイルすると、分岐命令、コール命令の参照が未定義で残されたR-Codeが生成される。これをR-Codeローダが、Q-Codeに変換する。Q-Codeは、仮想機械Qマシンの機械命令であり、Q-Codeインタプリタが実行する。マイクロプランコンパイラは、最終的に2kBほどのQ-Codeとして実行される。当時、最も小さなTiny BASICが2kBほどであったので、コンパイラとしては非常にコンパクトであった。R-CodeローダとQ-Codeインタプリタは、8080マイコンのアセンブリコードで記述されており、両方合わせた実行コードは1kBほどであったので、4kBのメモリがあれば、自分自身をコンパイルすることができた。ただし、ジャンプ命令、コール命令のオフセットが12bitしかないので、メモリ空間はわずか4kBであった。

2021年の忘年会シーズンに、昔の研究室の同僚と会話していて、マイクロプランのことを思い出した。私(松井俊浩）は、1978年当時、大学3年生で、6502マイコンを育てており、このマイクロプランの記事を見て、コレダ！と思い、6502用に改造して実装したのだった。記事に掲載されていたマイクロプランコンパイラのR-Codeの16進ダンプを見て、手で打ち込んだ。R-Codeローダ、Q-Codeインタプリタの8080のアセンブリコードを6502で書き換えた。結果、小さな6502マイコンで、コンパイラ型の言語が動くようになり、オセロのプログラムを書いたり、ペントミノパズルの解を全部求めたりして遊んだ。研究室の先輩が、bit増刊号の記事を送ってくれたので、今、これを再現したらどういうことになるかと思った。私は、大学院でプログラミングの授業を担当しており、言語の仕様やそれがコンパイルされる有様を講義するのだが、そこでコンパイラのすごい能力や謎に興味を持つ学生も多い。コンパイラを解剖して中を見せてあげたいが、GCCなどは手に余るほど複雑である。マイクロプランなら、非常に小さいから、言語処理系の講義にも適していると思う。

再現してみると、これを公開したくなる。苦労して戸村哲氏に連絡を取って公開に賛同いただき、その意見にしたがってbit誌の共立出版にも著作権の許可をいただいた。bit誌は、残念ながら2000年頃に廃刊になったが、今は、PDF版が復刻されて、Amazonでも入手可能である。しかし、増刊号は手に入らない！

古い記事をスキャンしてOCRでテキストファイルに直そうとしたのだが、何せ、7x9のドットプリンタの出力であり、スキャンも不鮮明であったので、得られたテキストファイルには大量の誤りがあった。(と\[、)とJ、Oと0、1とl(el) などの見た目での取り間違いだから、人がエディタで見ても、間違いとは気づかない。最後に、シンボル表を出力するプログラムを書いてみたら、GENCODEがGENCOOEになっており、GENCODE1がGENCODElになっていた。表に二つ出てくるからおかしいとわかった。さらにタブコード(0x09)をスペースとは解釈しないようだし、コメントの中に日本語コードが入っていても誤動作するように見受けられた。はっきりいって、OCRなど使わず、人間がソースコードを打ち込む方が早く、間違いがなかったとすら思える。

R-Codeを打ち込む元気はなかったので、コンパイラをCで書き直した。これは簡単だった。さらに、仕様を見てR-CodeローダとQ-CodeインタプリタをCで書き直す。これも簡単だった。これで8－Queenプログラムをコンパイルして実行させることができた。次は、マイクロプランのコンパイラである。前記のように打ち間違いのないコンパイラソースを得るのは苦労した。さて、これで自分自身をコンパイルできるようになった。いくつかエラーがあって、デバッグしたが、一つ、なかなかわからないバグがあった。バグと言うより、仕様の違いである。マイクロプランには、シフト演算子がないので、乗除算を代わりに使っている。#x1234 div 16 は、#x123 になるという仕組みである。ところが、負の数のdiv, mod は、マイクロプランのQinterpreterと、C言語というかx86では、動作が異なるのだった。

コンパイラには、2点、改良が加えてある。1つは、ID表を内蔵させたことである。もともとは、ID表を外部から入力していたので、コンパイルしたいソースコードの前に、すべからくこのID表を書き込んでおく必要がある。これは面倒である。こんな風にID表を分離させてあるのは、ID表の初期化コードが数百バイトになるので、省メモリしたかったのだと思う。確かにメモリ空間を圧迫するが、4kBに収まってコンパイルできるのだから、コンパイラの初期化コードに含めるべきだろう。もう1点は、エントリポイント、Cで言うmain()のアドレスをR-Codeローダが記憶するが、これを不要にして、プログラムの先頭にジャンプ命令を入れて、エントリアドレスに飛ぶようにした。R-CodeローダとQ-Codeインタプリタを別プログラムとして実行するので、その間でエントリアドレスを引き渡すのが面倒だったからだ。Q-Codeインタプリタは、常にゼロ番地から実行を開始すれば良い。

そのほかにQcodeインタプリタには、実行トレースを出力したり、逆アセンブルするユーティリティを付けた。デバッグ用に必要だったのだが、コンパイラの動作理解にも役立つだろう。同時に、シンボル表を出力するようにしている。これもデバッグ用である。

さて、性能はどうか？　記憶では、8bitの6502マイコンで、マイクロプラン・コンパイラをコンパイルするのには、1分くらいかかったのだが、今、AWSのx64で同じようにコンパイルすると、1.5msであった。1万倍以上高速になった！相変わらずメモリ空間は4kBであり、いろいろと改良したくなるが、教育用以外に役に立つことはないだろう。教育用には、シンプルなままがよいだろうということで、このまま公開することにする。

## C版microplan コンパイラとローダ､実行系

マイクロプランコンパイラは、microplan 自身で記述されているが、そのままでは実行できないので、Cに書き換える。コンパイラの本体は、mpc.c として再現した｡8080のアセンブリで書かれたR-codeローダ、Q-codeインタプリタもCで記述する｡
マイクロプランのソースプログラムは､mpcでR-codeにコンパイルされ､拡張子=.rc のR-codeファイルにストアされる｡R-codeローダである mpld は、このR-code ファイルを読み込んで､拡張子=.qc のQ-codeファイルを作成する｡同時に､拡張子=.sym のシンボル表を書き出す｡シンボル表には、関数と手続きの名前とその16進アドレスが列挙される｡最後に､メインプログラムのエントリアドレスが追記される｡その名前は、mainと小文字であることに注意｡できあがった.qc, .sym ファイルを参照して､mpx がQ-codeを解釈実行する｡実行に.symファイルは不要であるが､-d オプションを与えると、実行トレースが表示され､CALL命令のオペランドとして手続き･関数名が表示できる｡さらに、mpqdisasm は、.qc と.symから、Q-code を逆アセンブルする｡

### mpc [-d] <filename>

<filename>.mp をマイクロプランのソースコードとしてコンパイルし、結果のR-codeを<filename>.rc に書き出す。-dを付けると、コンパイル中に読み込んだソースコードをstderrに順次表示するので、error が出た場合、その場所がわかる。

### mpld [-d] <filename>

<filename>.rc をRコードのファイルとして入力し、ロードした結果のメモリイメージを<filename>.qc に書き出す。また、シンボル表を<filename>.sym に書き出す。

### mpx [-d] [-c] [-r] [-i <infile>] [-o <outfile>] <filename>

<filename>.qc をQコードファイルとして読み込み、また<filename>.sym をシンボル表として読み込んで、Qコードの先頭(ゼロ番地）から実行を開始する。ゼロ番地には､メインプログラムへのジャンプ命令が入っている｡最後に、実行された命令数とclock数(マイクロ秒単位）が表示される｡
 -i, -o は、実行されるマイクロプランプログラムの入出力ファイルを指定する｡指定が無い場合､stdin と stdout が適用される｡
 -d (debug) を指定すると､実行される命令が逆アセンブル表示される　(トレースモード）。
 -c は、call traceモードで、call命令が実行されると何が呼び出されるか表示

### mpq [-t <symfile>] <filename>

 Q-code である <filename>.qc とそのシンボル表である<filename>.sym を読み込んで、逆アセンブルしたリストを表示(stdout)する｡
